Практическая работа №14: «Работа с Fetch API»
Fetch API vs XMLHttpRequest?
Fetch API современнее и проще в использовании. Он основан на Promises, что делает код чище и позволяет удобно использовать async/await. XMLHttpRequest (XHR) использует callback'и и имеет более громоздкий синтаксис. Fetch предоставляет более логичный API для работы с запросами и ответами.

Как обрабатываются ошибки в Fetch API?
Fetch не отклоняет промис при HTTP-статусах 4xx/5xx (например, 404). Промис отклоняется только при сетевой ошибке или если запрос не удалось выполнить. Чтобы обработать HTTP-ошибку, нужно проверять свойство response.ok или response.status вручную после получения ответа и в случае ошибки бросать исключение.

Какие методы HTTP поддерживает Fetch API?
Все основные: GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS. Метод указывается в свойстве method объекта конфигурации, передаваемого вторым аргументом в fetch().

Как работать с заголовками?
Заголовки запроса: передаются в объекте конфигурации в свойстве headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ...' }.
Заголовки ответа: доступны через response.headers, который является итерируемым объектом. Можно использовать методы headers.get('Content-Type').

Разница между PUT и PATCH?
PUT используется для полного обновления ресурса. Клиент отправляет весь объект, даже если меняет одно поле. Сервер заменяет старую версию ресурса на новую.
PATCH используется для частичного обновления. Клиент отправляет только те поля, которые нужно изменить. Это более эффективно с точки зрения трафика.

Как реализовать авторизацию в Fetch API?

Basic Auth: 'Authorization': 'Basic ' + btoa(username + ':' + password)

Bearer Token (JWT): 'Authorization': 'Bearer ' + token

OAuth2: Обычно также использует Bearer Token в заголовке Authorization. Для получения токена может потребоваться предварительный запрос.

Способы отмены запросов?
С помощью AbortController. Создаем контроллер, передаем его сигнал (signal) в опции fetch. Для отмены вызываем abortController.abort(). Это отклоняет промис fetch с ошибкой AbortError.

Как работать с разными форматами данных?

JSON: await response.json()

Текст: await response.text()

Blob (бинарные данные, картинки): await response.blob()

FormData: Для отправки, создаем объект FormData и передаем его как body. Заголовок 'Content-Type' устанавливать не нужно, fetch сделает это сам.

Как оптимизировать производительность?

Параллельные запросы через Promise.all.

Кэширование ответов (как на клиенте, так и с помощью HTTP-заголовков кэширования от сервера).

Использование CDN.

Отмена неактуальных запросов (AbortController).

Сжатие данных (gzip, brotli) на стороне сервера.

Лучшие практики для production?

Централизованная обработка ошибок (интерцепторы).

Базовая настройка URL и заголовков для всех запросов.

Таймауты на запросы.

Повторные попытки для неудачных запросов.

Индикация загрузки для пользователя.

Безопасная обработка пользовательских данных перед отправкой.

