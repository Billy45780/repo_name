Практическая работа №12: «JavaScript: обработка событий»
preventDefault() vs stopPropagation()?
preventDefault() отменяет стандартное поведение браузера (например, переход по ссылке, отправку формы). stopPropagation() останавливает всплытие события по DOM-дерею, чтобы оно не достигло родительских элементов. Используются вместе, когда нужно и отменить действие по умолчанию, и не дать событию всплыть.

Как работает делегирование событий?
Делегирование — это назначение одного обработчика на родительский элемент для обработки событий от его потомков. Событие всплывает до родителя, и мы, проверяя event.target, можем определить, на каком именно потомке оно произошло. Преимущества: экономия памяти (один обработчик вместо многих) и работа с динамически добавляемыми элементами.

Фазы жизненного цикла события?

Capturing (перехват): Событие идет от корня документа вниз к целевому элементу.

Target (цель): Событие достигло целевого элемента.

Bubbling (всплытие): Событие поднимается от целевого элемента обратно к корню.
Обработчики по умолчанию выполняются на фазе всплытия. Чтобы поймать событие на фазе перехвата, нужно использовать третий аргумент addEventListener: true.

event.target vs event.currentTarget?
event.target — это элемент, на котором произошло событие (источник). event.currentTarget — это элемент, на котором в данный момент выполняется обработчик (на который мы "повесили" слушатель). В делегировании currentTarget — это родитель, а target — кликнутый потомок.

Как создать и запустить кастомное событие?
Создаем событие через конструктор CustomEvent, передавая имя события и объект опций (в detail можно положить данные). Затем запускаем его на нужном элементе с помощью dispatchEvent().

javascript
const event = new CustomEvent('myEvent', { detail: { message: 'Hello' } });
elem.dispatchEvent(event);
Debounce и Throttle?
(См. ответ на вопрос 8 из ПР10). Debounce для поиска, Throttle для скролла/ресайза. Эффективно для производительности, чтобы не перегружать браузер частыми вызовами.

Методы удаления обработчиков?
removeEventListener('click', handlerFunc). Важно передать ту же самую функцию, что и в addEventListener. Именно поэтому для удаления лучше использовать именованную функцию, а не анонимную. Удаление важно для предотвращения утечек памяти, особенно в SPA.

Обработка ошибок загрузки ресурсов?
Для изображений используются события load (успешная загрузка), error (ошибка). Для скриптов можно использовать атрибут onerror. Нужно предусматривать "заглушки" на случай ошибки загрузки картинки.

addEventListener vs onclick?
addEventListener позволяет добавить несколько обработчиков на одно событие для элемента. Прямое присваивание onclick перезаписывает предыдущий обработчик. addEventListener также дает больше контроля (фаза перехвата) и является современным стандартом.

Оптимизация производительности событий?
Использовать делегирование событий, избегать частых операций в обработчиках (например, пересчет layout), использовать debounce/throttle для "тяжелых" событий (scroll, resize, mousemove), удалять ненужные обработчики.