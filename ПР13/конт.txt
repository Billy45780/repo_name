Практическая работа №13: «JavaScript: асинхронные операции»
Promise.then().catch() vs async/await?
Promise.then().catch() — это цепочка методов, функциональный стиль. async/await — синтаксический сахар, который делает асинхронный код похожим на синхронный, что улучшает читаемость. async/await проще для обработки последовательных операций и использования циклов/условий. Выбор зависит от стиля и конкретной задачи, часто их комбинируют.

Как работает Promise.all?
Promise.all принимает массив промисов и возвращает новый промис, который выполнится, когда выполнятся все промисы в массиве, или отклонится, если хотя бы один из промисов будет отклонен. Результатом будет массив результатов в том же порядке. Если один промис "упадет", весь Promise.all немедленно завершится с этой ошибкой.

Разница между Promise.all, Promise.race, Promise.allSettled?

Promise.all: Успех только если все успешны. Первая ошибка — общий провал.

Promise.race: Возвращает результат (успех или ошибку) первого завершившегося промиса.

Promise.allSettled: Ждет завершения всех промисов (успех или ошибка) и возвращает массив с информацией о статусе и результате каждого. Полезно, когда нужно знать исход всех операций, независимо от успеха.

Как реализовать повторные попытки (retry logic)?
С помощью цикла (for/while) и try/catch внутри async-функции. В случае ошибки в catch увеличиваем задержку (например, экспоненциально — delay *= 2) с помощью await new Promise(resolve => setTimeout(resolve, delay)) и делаем следующую попытку, пока не исчерпаем лимит.

Что такое "состояние гонки" (race condition)?
Это ситуация, когда результат выполнения программы зависит от порядка завершения асинхронных операций, который непредсказуем. Например, если отправить два запроса на обновление одних и тех же данных, ответ может прийти в произвольном порядке. Лечится с помощью отмены запросов (AbortController), правильной последовательности операций или блокировок на стороне сервера.

Кэширование асинхронных запросов?
Создается объект (Map), где ключ — параметры запроса (например, URL), а значение — промис с результатом. При повторном запроse с теми же параметрами возвращается закэшированный промис. Можно добавить TTL (время жизни) для инвалидации кэша.

Методы оптимизации множественных операций?

Параллельное выполнение: Promise.all для независимых запросов.

Ограничение количества одновременных запросов (пул).

Кэширование результатов.

Отмена неактуальных запросов (AbortController).

Обработка ошибок в цепочках промисов?
Один блок .catch() в конце цепочки перехватит любую ошибку на любом этапе. Важно не "проглотить" ошибку молча, а либо обработать, либо пробросить дальше (например, throw new Error(...) в .then() или catch).

Преимущества async/await?

Код легче читать и писать (синхронный стиль).

Упрощается обработка ошибок с помощью try/catch.

Упрощается использование циклов и условных конструкций с асинхронными операциями.

Проще отлаживать, так call stack выглядит понятнее.

Как отлаживать асинхронный код?

console.log в ключевых точках (но может быть неочевидно из-за асинхронности).

Точки останова (breakpoints) в инструментах разработчика. Можно ставить прямо на строку с await.

Вкладка "Sources" в Chrome DevTools, отслеживание Call Stack.

async stack traces (современные браузеры показывают полную цепочку асинхронных вызовов).