Практическая работа №9: «JavaScript: базовые алгоритмы»
В чем разница между временной сложностью O(n) и O(n²)?
O(n) означает, что время выполнения алгоритма растет линейно с увеличением объема данных. Например, поиск элемента в неотсортированном массиве перебором. O(n²) означает, что время выполнения растет квадратично. Классический пример — пузырьковая сортировка, где для каждого элемента нужно проверить все остальные.

Как работает алгоритм бинарного поиска?
Бинарный поиск работает только на отсортированном массиве. Алгоритм делит массив пополам, сравнивает искомый элемент с элементом в середине. Если искомый элемент больше, поиск продолжается в правой половине, если меньше — в левой. Процесс повторяется до нахождения элемента. Сложность O(log n), потому что на каждом шаге область поиска уменьшается вдвое.

Преимущества и недостатки пузырьковой сортировки?
Преимущества: проста в понимании и реализации, не требует дополнительной памяти.
Недостатки: очень низкая эффективность на больших массивах (O(n²)), на практике почти не используется.

Как оптимизировать функцию проверки на простое число?
Вместо проверки всех чисел от 2 до n-1, достаточно проверять делители от 2 до квадратного корня из n (Math.sqrt(n)). Также можно сразу отсекать четные числа, кроме двойки.

Разница между рекурсивной и итеративной реализацией Фибоначчи?
Рекурсивная: читается легче, но имеет экспоненциальную сложность O(2^n) без оптимизаций (много повторных вычислений).
Итеративная: сложнее для чтения, но работает за линейное время O(n) и использует постоянную память O(1).

Какие методы отладки использовали?
Использовал console.log для вывода промежуточных значений переменных и аргументов функций. Также использовал отладчик в браузере, чтобы пошагово отслеживать выполнение кода и смотреть call stack.

Как работает алгоритм Евклида?
Алгоритм Евклида находит НОД двух чисел путем последовательного деления большего числа на меньшее, пока остаток не станет равен нулю. НОД будет последним ненулевым остатком. Он эффективен, потому что быстро сходится.

Какие edge cases для алгоритмов с массивами?
Пустой массив, массив с одним элементом, массив с одинаковыми элементами, массив с отрицательными числами, массив с очень большими числами.

Как улучшить удаление дубликатов для больших массивов?
Использовать Set, так как он хранит только уникальные значения и операция добавления в него имеет в среднем сложность O(1). Это эффективнее, чем проверка indexOf в цикле (O(n²)).

Какие принципы чистого кода применили?
Давал функциям понятные имена (isPrime, findMax), избегал магических чисел, использовал константы, старался делать функции небольшими и с одной ответственностью, добавлял комментарии к сложным моментам.

