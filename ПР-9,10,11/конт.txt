Практическая работа №9: «JavaScript: базовые алгоритмы»
В чем разница между временной сложностью O(n) и O(n²)?
O(n) означает, что время выполнения алгоритма растет линейно с увеличением объема данных. Например, поиск элемента в неотсортированном массиве перебором. O(n²) означает, что время выполнения растет квадратично. Классический пример — пузырьковая сортировка, где для каждого элемента нужно проверить все остальные.

Как работает алгоритм бинарного поиска?
Бинарный поиск работает только на отсортированном массиве. Алгоритм делит массив пополам, сравнивает искомый элемент с элементом в середине. Если искомый элемент больше, поиск продолжается в правой половине, если меньше — в левой. Процесс повторяется до нахождения элемента. Сложность O(log n), потому что на каждом шаге область поиска уменьшается вдвое.

Преимущества и недостатки пузырьковой сортировки?
Преимущества: проста в понимании и реализации, не требует дополнительной памяти.
Недостатки: очень низкая эффективность на больших массивах (O(n²)), на практике почти не используется.

Как оптимизировать функцию проверки на простое число?
Вместо проверки всех чисел от 2 до n-1, достаточно проверять делители от 2 до квадратного корня из n (Math.sqrt(n)). Также можно сразу отсекать четные числа, кроме двойки.

Разница между рекурсивной и итеративной реализацией Фибоначчи?
Рекурсивная: читается легче, но имеет экспоненциальную сложность O(2^n) без оптимизаций (много повторных вычислений).
Итеративная: сложнее для чтения, но работает за линейное время O(n) и использует постоянную память O(1).

Какие методы отладки использовали?
Использовал console.log для вывода промежуточных значений переменных и аргументов функций. Также использовал отладчик в браузере, чтобы пошагово отслеживать выполнение кода и смотреть call stack.

Как работает алгоритм Евклида?
Алгоритм Евклида находит НОД двух чисел путем последовательного деления большего числа на меньшее, пока остаток не станет равен нулю. НОД будет последним ненулевым остатком. Он эффективен, потому что быстро сходится.

Какие edge cases для алгоритмов с массивами?
Пустой массив, массив с одним элементом, массив с одинаковыми элементами, массив с отрицательными числами, массив с очень большими числами.

Как улучшить удаление дубликатов для больших массивов?
Использовать Set, так как он хранит только уникальные значения и операция добавления в него имеет в среднем сложность O(1). Это эффективнее, чем проверка indexOf в цикле (O(n²)).

Какие принципы чистого кода применили?
Давал функциям понятные имена (isPrime, findMax), избегал магических чисел, использовал константы, старался делать функции небольшими и с одной ответственностью, добавлял комментарии к сложным моментам.

Практическая работа №10: «JavaScript: работа с функциями»
Разница между Function Declaration и Function Expression?
Function Declaration объявляется как отдельная конструкция function name() {} и полностью "всплывает" (hoisted), поэтому ее можно вызвать до объявления. Function Expression создается внутри другого выражения const name = function() {} и не всплывает; доступна только после присваивания.

Rest parameters vs arguments object?
Rest parameters (...args) — это настоящий массив, с ним можно использовать методы типа map, reduce. arguments — это объект, подобный массиву, но не массив. Для работы с ним как с массивом нужно преобразовывать, например, Array.from(arguments). Rest parameters современнее и удобнее.

Что такое замыкание?
Замыкание — это когда функция запоминает свое лексическое окружение (переменные внешней функции), в котором она была создана, даже после того, как внешняя функция завершила выполнение. Это позволяет создавать приватные переменные и функции-фабрики.

Рекурсия vs итерация?
Рекурсия: код часто короче и читаемее для задач, которые по своей природе рекурсивны (обход дерева, факториал). Риск переполнения стека вызовов.
Итерация: обычно эффективнее по памяти, нет риска переполнения стека. Код может быть менее интуитивным для сложных рекурсивных задач.

Функции высшего порядка?
Это функции, которые принимают другие функции в качестве аргументов и/или возвращают функцию как результат. Встроенные методы массивов map, filter, reduce, forEach являются функциями высшего порядка.

Что такое каррирование?
Каррирование — это преобразование функции от нескольких аргументов в последовательность функций, каждая из которых принимает один аргумент. Например, add(1, 2) превращается в add(1)(2). Позволяет создавать специализированные функции на лету и удобно для частичного применения.

Как работает мемоизация?
Мемоизация — это кэширование результатов вызовов функции для одних и тех же аргументов. При повторном вызове с теми же аргументами функция возвращает результат из кэша, а не вычисляет его заново. Эффективно для "чистых" функций с дорогими вычислениями (например, вычисление факториала, чисел Фибоначчи).

Разница между debounce и throttle?
Debounce откладывает вызов функции до тех пор, пока не пройдет определенный период времени без новых вызовов. Например, для поиска по вводу в реальном времени — запрос отправляется, когда пользователь перестал печатать.
Throttle гарантирует, что функция будет вызываться не чаще, чем один раз в указанный промежуток времени. Например, для обработки события скролла или изменения размера окна.

Функции-генераторы?
Функции-генераторы (function*) могут приостанавливать свое выполнение и возобновлять его позже. Они возвращают специальный объект-генератор, с которым можно взаимодействовать через методы next(), return(), throw(). Полезны для работы с потоками данных, асинхронными операциями и создания итераторов.

Принципы функционального программирования?
Использовал чистые функции (без сайд-эффектов), функции высшего порядка (map, filter, собственные реализации), композицию функций (compose), избегал мутаций исходных данных (создавал новые массивы в myMap, myFilter). Это делает код более предсказуемым, тестируемым и удобным для отладки.

Практическая работа №11: «JavaScript: манипуляции DOM-деревом»
В чем разница между innerHTML и textContent?
innerHTML возвращает или устанавливает HTML-разметку внутри элемента, включая теги. Если установить значение через innerHTML, браузер его парсит, что может быть уязвимо для XSS-атак. textContent работает только с текстом, игнорируя любые теги. Он безопаснее и обычно быстрее, когда нужно работать именно с текстом.

Как работает делегирование событий?
Делегирование — это когда мы вешаем один обработчик на родительский элемент, а не на каждый дочерний. События от дочерних элементов всплывают, и мы можем обработать их в родителе, проверив event.target. Это очень удобно для динамически добавляемых элементов и экономит память.

Методы поиска элементов в DOM: getElementById, querySelector, querySelectorAll?

getElementById — ищет элемент по его ID. Возвращает один элемент.

querySelector — ищет первый элемент, подходящий под CSS-селектор.

querySelectorAll — ищет все элементы, подходящие под селектор, и возвращает статическую NodeList.
querySelector и querySelectorAll более гибкие, так как могут использовать любые CSS-селекторы.

Как предотвратить стандартное поведение элемента?
С помощью метода event.preventDefault(). Это нужно, например, чтобы форма не отправлялась по умолчанию, а обрабатывалась нашим скриптом, или чтобы ссылка не вела по своему href, а выполняла какое-то действие на странице.

Разница между classList.add() и className?
className — это строка, которая полностью перезаписывает все классы элемента. Если нужно добавить один класс, придется вручную склеивать строки. classList — это объект с удобными методами (add(), remove(), toggle(), contains()), которые позволяют точечно управлять классами, не затрагивая остальные.

Как создать и добавить элемент в DOM?
Основные способы:

document.createElement() + appendChild() / append() — самый чистый и рекомендуемый способ.

innerHTML — может быть удобно для простой вставки HTML-строки, но рискованно.

insertAdjacentHTML() — хорош для вставки HTML в определенную позицию относительно элемента.
Наиболее эффективен createElement, так как он не заставляет браузер парсить всю строку HTML заново.

Что такое всплытие событий и stopPropagation()?
Всплытие — это процесс, когда событие от целевого элемента поднимается вверх по DOM-дерею к его родителям. stopPropagation() останавливает это всплытие, и событие не достигнет родительских элементов. Это нужно, когда обработчик на дочернем элементе должен выполниться, а на родителе — нет.

Как получить данные из формы?
Есть несколько способов:

Через FormData: const data = new FormData(formElement). Самый современный и удобный способ, особенно для форм с файлами.

Через доступ к каждому полю по name: formElement.inputName.value.

Через перебор элементов формы: formElement.elements.
FormData чаще всего предпочтительнее.

События для обработки ввода: input, change, keyup?

input — срабатывает сразу при изменении значения в поле ввода (например, при каждой нажатой клавише). Лучше всего подходит для отслеживания ввода в реальном времени.

change — срабатывает, когда элемент теряет фокус и его значение изменилось. Подходит для выпадающих списков (<select>) и файловых полей.

keyup — срабатывает при отпускании клавиши. Более низкоуровневое, привязано к клавиатуре, а не к значению.

Как оптимизировать производительность при частых манипуляциях с DOM?

Минимизировать количество обращений к DOM. Лучше один раз прочитать значение в переменную, чем много раз обращаться к элементу.

Использовать фрагменты документа (DocumentFragment) для массового добавления элементов. Это позволяет собрать целую структуру в памяти и вставить ее в DOM одним действием.

Изменять классы, а не инлайн-стили, где это возможно, так как браузер лучше оптимизирует перерисовку.

Использовать делегирование событий, чтобы уменьшить количество обработчиков.
